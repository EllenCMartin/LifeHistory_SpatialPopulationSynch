## R code for Martin et al. 2022. Journal of Animal Ecology:
## Generation time and seasonal migration explain variation in spatial population synchrony across European bird species
## Ellen C. Martin1*, Brage Bremset Hansen1,2, Aline Magdalena Lee1 & Ivar Herfindal1  

##1. Centre for Biodiversity Dynamics, Dept. of Biology, Norwegian University of Science and Technology, 7491 Trondheim, Norway; 2. Dept. of Terrestrial Ecology, Norwegian Institute for Nature Research, 7485 Trondheim, Norway.
##*Corresponding author: Ellen C. Martin, ellen.c.martin@ntnu.no


############## SWITZERLAND 
## Switzerland Breeding Bird Survey
## Data provided: September 11, 2020, Hans Schmid at the Swiss Ornighological Institute [personal communication], data sharing agreement
## Updated 13 03 2023
## Load packages
library(dplyr)
library(reshape2)
library(tidyr)
library(ggplot2)
library(tidyverse)
library(geosphere)
library(sf)
library(mapsf)
library(rgdal)
library(mvtnorm)
library(RColorBrewer)
library(dplyr)
library(data.table)
library(Hmisc)


## Define functions for estimating synchrony ####
GaussSyncE <- function(rho.0, rho.inf, x, lambda) (rho.0-rho.inf)*exp(-(x^2)/(2*lambda^2)) + rho.inf #Sjekk parantesen i siste term
ExpSyncE <- function(rho.0, rho.inf, x, lambda) (rho.0-rho.inf)*exp(-x/lambda) + rho.inf # Sjekk parantesen i siste term

GaussSyncF <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  rho.0 <- exp(par[1])/(1+exp(par[1]))
  rho.inf <- rho.0*exp(par[2])/(1+exp(par[2]))          
  lambda <- exp(par[3])
  if (startVal){
    cat(round(c(rho.0, rho.inf, lambda)),3)
  }
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- (rho.0-rho.inf)*exp(-(distmatsel^2)/(2*lambda^2)) + rho.inf
    diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}
GaussSyncFboot <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  rho.0 <- exp(par[1])/(1+exp(par[1]))
  rho.inf <- rho.0*exp(par[2])/(1+exp(par[2]))          
  lambda <- exp(par[3])
  if (startVal){
    cat(round(c(rho.0, rho.inf, lambda)),3)
  }
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- (rho.0-rho.inf)*exp(-(distmatsel^2)/(2*lambda^2)) + rho.inf
    #diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}

GaussSyncFFix <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- matrix(par, nr=sum(sel), nc=sum(sel))
    diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}
ExpSyncF <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  rho.0 <- exp(par[1])/(1+exp(par[1]))
  rho.inf <- rho.0*exp(par[2])/(1+exp(par[2]))          
  lambda <- exp(par[3])
  if (startVal){
    cat(round(c(rho.0, rho.inf, lambda)),3)
  }
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- (rho.0-rho.inf)*exp(-distmatsel/lambda) + rho.inf
    diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}

## Importing and formatting Switzerland Bird Survey Data ####################################################################################################
BirdLocs <- read.csv("locations_SwissOrnithologicalInstitute.csv")# Load the bird location data
BirdLocs <- st_as_sf(x=BirdLocs, coords=c("longitude", "latitude"), crs=lonlatproj) # Make it an sf object
BirdData <- read.csv("SwissOrnithologicalInstitute_RAW.csv") ## Load the bird observation data ####

## Swiss cantonal boundaries accessed from: Federal Office of Topography swisstopo [https://www.swisstopo.admin.ch/en/geodata/landscape/boundaries3d.html]
Kantons <- sf::st_read(dsn="swissBOUNDARIES3D_1_3_LV95_LN02.gdb", 
                        layer="TLM_KANTONSGEBIET")

## Define projections for sf objects. Layers are EPSG and WGS84: want to transform to UTM33
UTM33proj <- "+proj=utm +zone=33 +datum=WGS84"
lonlatproj <- "+proj=longlat +unit=dd +datum=WGS84"

# Transform from projection "CH1903 + / LV95" into UTM zone 32
KantonsUTM <- st_transform(Kantons, crs=UTM33proj) # Transform Kantons to UTM
BirdLocsUTM <- st_transform(BirdLocs, crs=UTM33proj) # Transform BirdLocs to UTM

## Spatial overlay to assign points to kantons ####
pointsinkanton <- st_intersects(BirdLocsUTM, KantonsUTM)
testttt <- unlist(lapply(pointsinkanton, function(x) ifelse(length(x)==0, NA, as.vector(KantonsUTM$NAME)[x])))
BirdLocsUTM[,"NAME"] <- testttt

# Merge Bird Count data with bird location data to get the kantons
BirdData <- merge(BirdData, data.frame(BirdLocsUTM), by="samplearea_id")

# Aggregate the counts by the Kantons (NAME)
BirdData[is.na(BirdData)] <- 0 # Include NA as 0, but that is likely not correct
BirdDataAgg <- aggregate(cbind(X1999, X2000, X2001, X2002, X2003, 
                               X2004, X2005, X2006, X2007, 
                               X2008, X2009, X2010, X2011, X2012, 
                               X2013, X2014, X2015, X2016, X2017, 
                               X2018, X2019, X2020)~NAME+nameeg, data=BirdData, 
                         FUN=function(x) sum(x, na.rm=TRUE))

unique.species <- unique(BirdDataAgg$nameeg)
unique.species_numbered <- 1:length(unique.species)
names(unique.species_numbered) <- unique.species
names(unique.species_numbered)

## Grouping cantons so that cantons with few surveys are clustered by proximity. 
## Done manually. Do for both the intersection object and the KantonsUTM ####
intersection <- st_intersection(x = BirdLocsUTM, y = KantonsUTM)

#Combine Gen?ve + Vaud
BirdLocsUTM$NAMECOMBINED <- sub("Gen?ve|Vaud", "Gen?ve + Vaud", BirdLocsUTM$NAME)
# Combine Neuch?tel + Jura
BirdLocsUTM$NAMECOMBINED <- gsub("Neuch?tel|Jura", "Neuch?tel + Jura", BirdLocsUTM$NAMECOMBINED)
# Combine Thurgau + Schaffhausen                 
BirdLocsUTM$NAMECOMBINED <- gsub("Thurgau|Schaffhausen", "Thurgau + Schaffhausen", BirdLocsUTM$NAMECOMBINED)
# Combine Schwyz + Glarus                 
BirdLocsUTM$NAMECOMBINED <- gsub("Schwyz|Glarus", "Schwyz + Glarus", BirdLocsUTM$NAMECOMBINED)
# Combine Uri + Nidwalden + Obwalden                      
BirdLocsUTM$NAMECOMBINED <- gsub("Uri|Nidwalden|Obwalden", "Uri + Nidwalden + Obwalden", BirdLocsUTM$NAMECOMBINED)
# Combine Solothurn + Basel                 
BirdLocsUTM$NAMECOMBINED <- gsub("Solothurn|Basel-Landschaft|Basel-Stadt", "Solothurn + Basel", BirdLocsUTM$NAMECOMBINED)
# Combine Appenzell Ausserrhoden + Appenzell Innerrhoden + St.Gallen                 
BirdLocsUTM$NAMECOMBINED <- gsub("St. Gallen|Appenzell Ausserrhoden|Appenzell Innerrhoden", "Appenzell + St.Gallen", BirdLocsUTM$NAMECOMBINED)
# Combine Zug + Z?rich                 
BirdLocsUTM$NAMECOMBINED <- gsub("Zug|Z?rich", "Zug + Z?rich", BirdLocsUTM$NAMECOMBINED)


##  Grouping cantons so that cantons with few surveys are clustered by proximity. Done manually. 
#Combine Gen?ve + Vaud
BirdDataAgg$NAMECOMBINED <- sub("Gen?ve|Vaud", "Gen?ve + Vaud", BirdDataAgg$NAME)
# Combine Neuch?tel + Jura
BirdDataAgg$NAMECOMBINED <- gsub("Neuch?tel|Jura", "Neuch?tel + Jura", BirdDataAgg$NAMECOMBINED)
# Combine Thurgau + Schaffhausen                 
BirdDataAgg$NAMECOMBINED <- gsub("Thurgau|Schaffhausen", "Thurgau + Schaffhausen", BirdDataAgg$NAMECOMBINED)
# Combine Schwyz + Glarus                 
BirdDataAgg$NAMECOMBINED <- gsub("Schwyz|Glarus", "Schwyz + Glarus", BirdDataAgg$NAMECOMBINED)
# Combine Uri + Nidwalden + Obwalden                      
BirdDataAgg$NAMECOMBINED <- gsub("Uri|Nidwalden|Obwalden", "Uri + Nidwalden + Obwalden", BirdDataAgg$NAMECOMBINED)
# Combine Solothurn + Basel                 
BirdDataAgg$NAMECOMBINED <- gsub("Solothurn|Basel-Landschaft|Basel-Stadt", "Solothurn + Basel", BirdDataAgg$NAMECOMBINED)
# Combine Appenzell Ausserrhoden + Appenzell Innerrhoden + St.Gallen                 
BirdDataAgg$NAMECOMBINED <- gsub("St. Gallen|Appenzell Ausserrhoden|Appenzell Innerrhoden", "Appenzell + St.Gallen", BirdDataAgg$NAMECOMBINED)
# Combine Zug + Z?rich                 
BirdDataAgg$NAMECOMBINED <- gsub("Zug|Z?rich", "Zug + Z?rich", BirdDataAgg$NAMECOMBINED)

##  Grouping cantons so that cantons with few surveys are clustered by proximity. Done manually. 
#Combine Gen?ve + Vaud
intersection$NAMECOMBINED <- sub("Gen?ve|Vaud", "Gen?ve + Vaud", intersection$NAME)
# Combine Neuch?tel + Jura
intersection$NAMECOMBINED <- gsub("Neuch?tel|Jura", "Neuch?tel + Jura", intersection$NAMECOMBINED)
# Combine Thurgau + Schaffhausen                 
intersection$NAMECOMBINED <- gsub("Thurgau|Schaffhausen", "Thurgau + Schaffhausen", intersection$NAMECOMBINED)
# Combine Schwyz + Glarus                 
intersection$NAMECOMBINED <- gsub("Schwyz|Glarus", "Schwyz + Glarus", intersection$NAMECOMBINED)
# Combine Uri + Nidwalden + Obwalden                      
intersection$NAMECOMBINED <- gsub("Uri|Nidwalden|Obwalden", "Uri + Nidwalden + Obwalden", intersection$NAMECOMBINED)
# Combine Solothurn + Basel                 
intersection$NAMECOMBINED <- gsub("Solothurn|Basel-Landschaft|Basel-Stadt", "Solothurn + Basel", intersection$NAMECOMBINED)
# Combine Appenzell Ausserrhoden + Appenzell Innerrhoden + St.Gallen                 
intersection$NAMECOMBINED <- gsub("St. Gallen|Appenzell Ausserrhoden|Appenzell Innerrhoden", "Appenzell + St.Gallen", intersection$NAMECOMBINED)
# Combine Zug + Z?rich                 
intersection$NAMECOMBINED <- gsub("Zug|Z?rich", "Zug + Z?rich", intersection$NAMECOMBINED)

#### Grouping cantons so that cantons with few surveys are clustered by proximity. Done manually. Do for both the intersection object and the KantonsUTM ####
#Combine Gen?ve + Vaud
KantonsUTM$NAMECOMBINED <- sub("Gen?ve|Vaud", "Gen?ve + Vaud", KantonsUTM$NAME)
# Combine Neuch?tel + Jura
KantonsUTM$NAMECOMBINED <- gsub("Neuch?tel|Jura", "Neuch?tel + Jura", KantonsUTM$NAMECOMBINED)
# Combine Thurgau + Schaffhausen                 
KantonsUTM$NAMECOMBINED <- gsub("Thurgau|Schaffhausen", "Thurgau + Schaffhausen", KantonsUTM$NAMECOMBINED)
# Combine Schwyz + Glarus                 
KantonsUTM$NAMECOMBINED <- gsub("Schwyz|Glarus", "Schwyz + Glarus", KantonsUTM$NAMECOMBINED)
# Combine Uri + Nidwalden + Obwalden                      
KantonsUTM$NAMECOMBINED <- gsub("Uri|Nidwalden|Obwalden", "Uri + Nidwalden + Obwalden", KantonsUTM$NAMECOMBINED)
# Combine Solothurn + Basel                 
KantonsUTM$NAMECOMBINED <- gsub("Solothurn|Basel-Landschaft|Basel-Stadt", "Solothurn + Basel", KantonsUTM$NAMECOMBINED)
# Combine Appenzell Ausserrhoden + Appenzell Innerrhoden + St.Gallen                 
KantonsUTM$NAMECOMBINED <- gsub("St. Gallen|Appenzell Ausserrhoden|Appenzell Innerrhoden", "Appenzell + St.Gallen", KantonsUTM$NAMECOMBINED)
# Combine Zug + Z?rich                 
KantonsUTM$NAMECOMBINED <- gsub("Zug|Z?rich", "Zug + Z?rich", KantonsUTM$NAMECOMBINED)

# Cantons post-aggregation to be used as new populations:
unique <- unique(intersection$NAMECOMBINED)

## Now need to aggregate the KantonsUTM in the spatial dataframe. Merging polygons of the cantons which are added together. 
mergedKantonsUTM <-KantonsUTM %>% 
  group_by(NAMECOMBINED) %>% 
  summarise(Shape = sf::st_union(Shape)) %>% 
  ungroup()


## Cleaning Data & Plotting Population Dynamics ####

# use only BirdLocs with more than 1 sampling points
npoints <- table(intersection$NAMECOMBINED)
subset <- npoints[npoints>1]
BirdLocsSubset <- BirdLocsUTM[BirdLocsUTM$NAMECOMBINED%in%names(subset),]
BirdDataAggSubset <- BirdDataAgg[BirdDataAgg$NAMECOMBINED%in%names(subset),]

Coords <- aggregate(st_coordinates(BirdLocsSubset), 
                    by=list(NAMECOMBINED=data.frame(BirdLocsSubset)[,"NAMECOMBINED"]), FUN=mean)
distmat <- dist(Coords[,c("X", "Y")], upper=TRUE)/1000

## If running analysis on speciic species, and selecting them manually:
Species <- c("Alpine Accentor", "Barn Swallow", "Black Redstart", "Carrion Crow", "Coal Tit", 
             "Common Chaffinch", "Common Chiffchaff",  "Common Cuckoo", "Common Firecrest", "Common Linnet",
             "Common Starling", "Common Swift", "Common Woodpigeon", "Crested Tit", "Dunnock", 
             "Eurasian Blackbird", "Eurasian Blackcap", "Eurasian Blue Tit","Eurasian Bullfinch", "Eurasian Buzzard", 
             "Eurasian Green Woodpecker", "Eurasian Jay", "Eurasian Magpie", "Eurasian Nuthatch", "Eurasian Skylark", 
             "Eurasian Tree Sparrow", "Eurasian Treecreeper","European Goldfinch", "European Greenfinch", "European Robin", 
             "European Serin", "Garden Warbler", "Goldcrest", "Great Spotted Woodpecker", "Great Tit", 
             "House Sparrow", "Marsh Tit", "Northern House Martin", "Northern Wheatear", "Mistle Thrush", 
             "Northern Wren","Ring Ouzel", "Short-toed Treecreeper", "Song Thrush", "Tree Pipit",
             "Western Bonelli's Warbler", "Water Pipit", "White Wagtail", "Yellowhammer")


## Merge common name with latin name for standard use across all datasets
NameMerge <- read.csv("C:\\Users\\ellencm\\NTNU\\Ellen C. Martin PhD - General\\PAPER II\\Trait Data\\LifeHistory_ALL.csv")
NameMerge <- NameMerge %>%
  select(c(commonname, nameeg))

SpeciesLatin <-  NameMerge %>%
  select(c(nameeg, commonname))
names(BirdDataAggSubset)[2] <- 'commonname'
BirdDataAggSubset <- merge(BirdDataAggSubset, SpeciesLatin, by = "commonname")

Speciesdf <- as.data.frame(Species)
names(Speciesdf)[1] <- 'commonname'
Speciesdf <- merge(Speciesdf, SpeciesLatin, by = "commonname")
Species <-  c("Prunella collaris" ,      "Hirundo rustica"       ,  "Phoenicurus ochruros"   ,
              "Corvus corone"  ,         "Periparus ater"     ,     "Fringilla coelebs"      ,
              "Phylloscopus collybita" , "Cuculus canorus"   ,      "Regulus ignicapilla"   , 
              "Carduelis cannabina",     "Sturnus vulgaris"   ,     "Apus apus"        ,      
              "Columba palumbus"   ,     "Lophophanes cristatus",   "Prunella modularis"  ,   
              "Turdus merula"       ,    "Sylvia atricapilla"  ,    "Cyanistes caeruleus"  ,  
              "Pyrrhula pyrrhula"    ,   "Buteo buteo"     ,        "Garrulus glandarius"  ,  
              "Pica pica" ,              "Sitta europaea" ,         "Alauda arvensis" ,       
              "Passer montanus"   ,      "Certhia familiaris" ,     "Carduelis carduelis",    
              "Chloris chloris" ,        "Erithacus rubecula"   ,   "Serinus serinus"    ,    
              "Sylvia borin"  ,          "Regulus regulus"     ,    "Dendrocopos major",      
              "Parus major"    ,         "Passer domesticus"    ,   "Poecile palustris" ,     
              "Turdus viscivorus",       "Oenanthe oenanthe"     ,  "Troglodytes troglodytes",
              "Turdus torquatus"  ,      "Certhia brachydactyla"  , "Turdus philomelos",      
              "Anthus trivialis"   ,     "Anthus spinoletta"       ,"Phylloscopus bonelli",   
              "Motacilla alba"      ,    "Emberiza citrinella")


### Before running analyses, need to standardize species names so they match across datasets ############
## Corvus cornix -> Corvus corone
Species[Species == "Corvus cornix"] <- "Corvus corone"
BirdDataAggSubset$nameeg[BirdDataAggSubset$nameeg == "Corvus cornix"] <- "Corvus corone"

## Linaria cannabina -> Carduelis cannabina
Species[Species == "Linaria cannabina"] <- "Carduelis cannabina"
BirdDataAggSubset$nameeg[BirdDataAggSubset$nameeg == "Linaria cannabina"] <- "Carduelis cannabina"

## Coloeus monedula -> Corvus monedula
Species[Species == "Coloeus monedula"] <- "Corvus monedula"
BirdDataAggSubset$nameeg[BirdDataAggSubset$nameeg == "Coloeus monedula"] <- "Corvus monedula"

## Phylloscopus sibillatrix -> Phylloscopus sibilatrix
Species[Species == "Phylloscopus sibillatrix"] <- "Phylloscopus sibilatrix"
BirdDataAggSubset$nameeg[BirdDataAggSubset$nameeg == "Phylloscopus sibillatrix"] <- "Phylloscopus sibilatrix"

## Reorder data and drop commonname column
BirdDataAggSubset <- BirdDataAggSubset[, c(26, 2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25)]

## Set up the synchrony analysis tables and lists:
SyncData <- BirdDataAggSubset[BirdDataAggSubset$nameeg%in%Species,] # check for the exclusion of poor sampling years
SyncDataList <- split(SyncData, f=list(
  SyncData$nameeg, SyncData$NAMECOMBINED), drop=TRUE)
SyncDataList <- lapply(SyncDataList, function(x) 
  reshape(x, direction="long", varying=paste0("X", 1999:2020), sep=""))
SyncDataList <- lapply(SyncDataList, function(x) 
  cbind.data.frame(x, log.abundance=ifelse((is.na(x$X)|x$X==0), NA, log(x$X))))
SyncDataList <- lapply(SyncDataList, function(x) 
  cbind.data.frame(x, log.r1=append(NA, diff(log(x$X))))) 
SyncDataList <- lapply(SyncDataList, function(x) 
  cbind.data.frame(x, log.r=ifelse(is.na(x$log.r1)|is.nan(x$log.r1)|is.infinite(x$log.r1), NA, x$log.r1)))


SyncDataList <- do.call(rbind.data.frame, SyncDataList)
SyncDataList <- split(SyncDataList, f=SyncDataList$nameeg)

# make wide format
SyncDataLogAb <- lapply(SyncDataList, function(x) 
  reshape(x[,c("time", "NAMECOMBINED", "log.abundance")], direction="wide", 
          idvar="time", timevar="NAMECOMBINED"))
SyncDataLogAb <- lapply(SyncDataLogAb, function(x) 
  scale(x[apply(x, 1, function(y) sum(!is.na(y))>1),-c(1)]))

SyncDatalogr <- lapply(SyncDataList, function(x) 
  reshape(x[,c("time", "NAMECOMBINED", "log.r")], direction="wide", 
          idvar="time", timevar="NAMECOMBINED"))
SyncDatalogr <- lapply(SyncDatalogr, function(x) 
  scale(x[apply(x, 1, function(y) sum(!is.na(y))>1),-c(1)]))


SyncLists <- list(log.abundance=SyncDataLogAb, 
                  log.r=SyncDatalogr)

spdata <- Coords
spdataCoord <- spdata[order(spdata$NAMECOMBINED),]
disttab <- as.matrix(dist(spdataCoord[,2:3], upper=TRUE, diag=FALSE)/1000) # divide with 1000 to get km
colnames(disttab) <- spdataCoord$NAMECOMBINED
rownames(disttab) <- spdataCoord$NAMECOMBINED

### Make separate loop here to calculate mean synchrony at distances of 350km, 1000km, and 500km.
SpeciesMeanbyDistance<-data.frame(nameeg=character(0), Mean1000ab=numeric(0), Mean500ab=numeric(0),
                                  Mean350ab=numeric(0), Mean1000r=numeric(0), Mean500r=numeric(0), 
                                  Mean350r=numeric(0), NumCorr1000=numeric(0), NumCorr500=numeric(0), 
                                  NumCorr350=numeric(0), MeanRawab=numeric(0), MeanRawr = numeric(0))
for(i in 1:length(Species))
{
  sp <- Species[i]
  synchdatawide <- SyncLists[["log.abundance"]][[sp]]
  cormat <- rcorr(synchdatawide)
  cormat$r
  meanrawab<-mean(cormat$r[disttab<4000], na.rm=TRUE)
  mean1000ab<-mean(cormat$r[disttab<1000], na.rm=TRUE) 
  mean500ab<-mean(cormat$r[disttab<500], na.rm=TRUE) 
  mean350ab<-mean(cormat$r[disttab<350], na.rm=TRUE)
  
  synchdatawider <- SyncLists[["log.r"]][[sp]]
  cormatr <- rcorr(synchdatawider)
  ## (sum(!is.na(cormatr$r))-15) tells number of pairwise correlations used to calculate meancorr
  ## cormatr$n tells the number of pairwise correlations used to calculate the meancorr 
  meanrawr<-mean(cormatr$r[disttab<4000], na.rm=TRUE)
  mean1000r<-mean(cormatr$r[disttab<1000], na.rm=TRUE) 
  disttab1000 <- disttab<1000
  disttab1000 <- length(disttab1000[disttab1000 == TRUE])
  mean500r<-mean(cormatr$r[disttab<500], na.rm=TRUE) 
  disttab500 <- disttab<500
  disttab500 <- length(disttab500[disttab500 == TRUE])
  mean350r<-mean(cormatr$r[disttab<350], na.rm=TRUE)
  disttab350 <- disttab<350
  disttab350 <- length(disttab350[disttab350 == TRUE])
  
  newrow<- data.frame(nameeg = as.character(sp), Mean1000ab = mean1000ab,   
                      Mean500ab = mean500ab,   
                      Mean350ab = mean350ab, Mean1000r = mean1000r, Mean500r = mean500r, Mean350r = mean350r,
                      NumCorr1000 = disttab1000, NumCorr500 = disttab500, NumCorr350 = disttab350, 
                      MeanRawab = meanrawab, MeanRawr = meanrawr) 
  
  SpeciesMeanbyDistance <- rbind(SpeciesMeanbyDistance, newrow)              # Apply rbind function
  
} 



SynchTab <- expand.grid(StartRho0=c(0.2,0.4,0.6,0.8), 
                        StartRhoInf=c(0,0.2,0.4,0.6), 
                        StartLambda=log(c(10,20,40,80,160,320, 1000)), 
                        nameeg=Species, 
                        SynchVar=c("log.abundance", "log.r"), 
                        MaxLik=NA,
                        rho.0=NA, rho.inf=NA, Lambda=NA, MeanRhos=NA, N.areas=NA,
                        stringsAsFactors=FALSE)

SynchTab <- SynchTab[SynchTab$StartRho0>=SynchTab$StartRhoInf,] # starting values for rho0 always greater than rhoinf

for(i in 1:nrow(SynchTab))
{
  start <- SynchTab[i,c("StartRho0", "StartRhoInf", "StartLambda")]
  
  sp <- SynchTab[i,"nameeg"]
  svar <- SynchTab[i,"SynchVar"]
  synchdatawide <- SyncLists[[svar]][[sp]]
  areas <- substr(colnames(synchdatawide), nchar(svar)+2, nchar(colnames(synchdatawide))) # need to get the names of areas with data, not all areas have all birds
  disttab2 <- disttab[areas, areas] #distance matrix must have same number of row and columns as number of areas
  gausssynch <- optim(start, GaussSyncF, distmat=disttab2, x=synchdatawide)
  gausssynchFix <- optimize(GaussSyncFFix, c(-1,1), distmat=disttab2, x=synchdatawide)
  SynchTab[i,"MaxLik"] <- gausssynch$value
  SynchTab[i,"rho.0"] <- exp(gausssynch$par[1])/(1+exp(gausssynch$par[1]))
  SynchTab[i,"rho.inf"] <- SynchTab[i,"rho.0"]*exp(gausssynch$par[2])/(1+exp(gausssynch$par[2]))
  SynchTab[i,"Lambda"] <- exp(gausssynch$par[3])
  SynchTab[i,"MeanRhos"] <- gausssynchFix$minimum
  SynchTab[i,"N.areas"] <- length(areas)
  print(paste(i, "of", nrow(SynchTab)))
  flush.console()
}
save(SynchTab, file="SynchTab_21092022.rda")
load("SynchTab_21092022.rda")

synchtabb <- with(SynchTab, tapply(MaxLik, list(nameeg, SynchVar), min))
SynchTabB <- SynchTab[SynchTab$MaxLik%in%synchtabb,]
SynchTabB['Dataset'] = 'Switzerland'
save(SynchTabB, file="SynchTab_Switzerland.rda")



## Load the life history trait data ####
## Combining generation length column with species name:
## Migration classification available from: Eyres, A., K. Bohning-Gaese, and S. A. Fritz. 2017. Quantification of climatic niches in birds: adding the temporal dimension. Journal of Avian Biology 48:1517-1531.
## Generation time data available from: Bird, J. P., R. Martin, H. R. Akçakaya, J. Gilroy, I. J. Burfield, S. T. Garnett, A. Symes, J. Taylor, Ç. H. Şekercioğlu, and S. H. M. Butchart. 2020. Generation lengths of the world`s birds and their implications for extinction risk. Conservation Biology 34:1252-1261.
Migrant <- read.csv("C:\\Users\\ellencm\\NTNU\\Ellen C. Martin PhD - General\\PAPER II\\Trait Data\\LifeHistory_ForPublication.csv")
head(Migrant)

MigData <- Migrant %>%
  select(c(commonname, nameeg))

## SwitzerlandMigClassification is column of manually entered migration classification per species
## SwitzerlandMigClassification comes from MoveBank.org.
SwitzerlandMigClassification <- Migrant %>%
  select(c(nameeg, Switzerland_Mig_Classification))

### Match species with generation time 
GenerationTime_Avian_ConsBio <- read.csv("C:\\Users\\ellencm\\NTNU\\Ellen C. Martin PhD - General\\PAPER II\\Trait Data\\GenerationTime_AvianDatabase_Bird_et_al_2020.csv")
Gen.Length <-  GenerationTime_Avian_ConsBio %>%
  select(c(nameeg, GenLength))

MigData <- merge(MigData, Gen.Length, by = "nameeg")
MigData2 <- merge(MigData, SwitzerlandMigClassification, by = "nameeg")

## rename Switzerland specific classification column:
names(MigData2)[names(MigData2) == "Switzerland_Mig_Classification"] <- "CountrySpecificCat"

## Join the migratory status of each species as new column to SynchTabB object ##
SynchTabMigMerge <- merge(SynchTabB, MigData2, by="nameeg")

## Join the mean rho by distance as a new column to SynchTabB object
SynchTabMigMerge2<- merge(SynchTabMigMerge, SpeciesMeanbyDistance, by = "nameeg") ## IF USING MEAN BY DISTANCE

## Remove duplicated species 
SynchTabMigMerge2 <- SynchTabMigMerge2 [!duplicated(SynchTabMigMerge2[c(1,5,6)]),]

save(SynchTabMigMerge2, file="SWITZERLAND_COUNTRYSPECIFIC_SYNCH.rda")


################ SWEDEN 
##############
## Swedish Breeding Bird Survey
## Data provided: March 2021 from GBIF DOI: https://doi.org/10.15468/hd6w0r (Lindström and Green 2021). 
## Updated 26 10 2022 

## Load packages
library(dplyr)
library(reshape2)
library(tidyr)
library(ggplot2)
library(tidyverse)
library(geosphere)
library(sf)
library(mapsf)
library(rgdal)
library(mvtnorm)
library(RColorBrewer)
library(dplyr)
library(data.table)
library(Hmisc)


## Define functions for estimating synchrony ####
GaussSyncE <- function(rho.0, rho.inf, x, lambda) (rho.0-rho.inf)*exp(-(x^2)/(2*lambda^2)) + rho.inf #Sjekk parantesen i siste term
ExpSyncE <- function(rho.0, rho.inf, x, lambda) (rho.0-rho.inf)*exp(-x/lambda) + rho.inf # Sjekk parantesen i siste term

GaussSyncF <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  rho.0 <- exp(par[1])/(1+exp(par[1]))
  rho.inf <- rho.0*exp(par[2])/(1+exp(par[2]))          
  lambda <- exp(par[3])
  if (startVal){
    cat(round(c(rho.0, rho.inf, lambda)),3)
  }
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- (rho.0-rho.inf)*exp(-(distmatsel^2)/(2*lambda^2)) + rho.inf
    diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}
GaussSyncFboot <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  rho.0 <- exp(par[1])/(1+exp(par[1]))
  rho.inf <- rho.0*exp(par[2])/(1+exp(par[2]))          
  lambda <- exp(par[3])
  if (startVal){
    cat(round(c(rho.0, rho.inf, lambda)),3)
  }
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- (rho.0-rho.inf)*exp(-(distmatsel^2)/(2*lambda^2)) + rho.inf
    #diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}

GaussSyncFFix <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- matrix(par, nr=sum(sel), nc=sum(sel))
    diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}
ExpSyncF <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  rho.0 <- exp(par[1])/(1+exp(par[1]))
  rho.inf <- rho.0*exp(par[2])/(1+exp(par[2]))          
  lambda <- exp(par[3])
  if (startVal){
    cat(round(c(rho.0, rho.inf, lambda)),3)
  }
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- (rho.0-rho.inf)*exp(-distmatsel/lambda) + rho.inf
    diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}

## Importing and formatting Sweden standardrutten Data ####################################################################################################
## Data imported from GBIF, available at: https://doi.org/10.15468/hd6w0r 
## Data accessed from GBIF on March, 2021
## All files needed for counts and midpoints contained within this file.

## Define projections for sf objects. Want to transform to UTM33. Region boundaries in Swedish reference system projection (EPSG:3006).
SWEREF99TM <- "+init=epsg:3006"
UTM33proj <- "+proj=utm +zone=33 +datum=WGS84"
lonlatproj <- "+proj=longlat +unit=dd +datum=WGS84"


## Import Sweden boundaries shapefile and count data ###
## Sweden boundaries shapefile available from: Valmyndigheten [(Esri 2021) Sweden] [https://hub.arcgis.com/datasets/dbae50c537864581895ac2ca2cf5320e/about]

Sweden <- sf::st_read("SwedenBoundaries/alla_lan.shp") ## Sweden boundaries
SwedenBird <- read.csv("workingdata_SBBS.csv", encoding = "UTF-8") ## Sweden bird count data

## Add unique identification to each lat.long combination called Cluster_ID
SwedenBird <- transform(SwedenBird, Cluster_ID = match(paste0(decimalLatitude, decimalLongitude), unique(paste0(decimalLatitude, decimalLongitude))))
# Make it an sf object
BirdDataSF <- st_as_sf(x=SwedenBird, coords=c("decimalLongitude", "decimalLatitude"), crs=lonlatproj)
# tranform to UTM zone 33 
BirdDataUTM <- st_transform(BirdDataSF, crs=UTM33proj)

SwedenLocs <- unique(SwedenBird[,c("decimalLatitude", "decimalLongitude", "level1pop", "level2pop")])
SwedenLocsSF <- st_as_sf(x=SwedenLocs, coords=c("decimalLongitude", "decimalLatitude"),
                       crs=lonlatproj)## Turn into a sf object

## Transform shapefile to UTM33 ####
SwedenUTM <- st_transform(Sweden, crs=UTM33proj)
SwedenLocsUTM <- st_transform(SwedenLocsSF, crs=UTM33proj)

## Spatial overlay to assign points to lans ####
pointsinlan <- st_intersects(SwedenLocsUTM, SwedenUTM)
testttt <- unlist(lapply(pointsinlan, function(x) ifelse(length(x)==0, NA, as.vector(SwedenUTM$LAN_NAMN)[x])))
SwedenLocsUTM[,"LAN_NAMN"] <- testttt


## Spatial overlay to assign count data to lans ####
countsinlan <- st_intersects(BirdDataUTM, SwedenUTM)
testttt <- unlist(lapply(countsinlan, function(x) ifelse(length(x)==0, NA, as.vector(SwedenUTM$LAN_NAMN)[x])))
BirdDataUTM[,"LAN_NAMN"] <- testttt



## Assign points which are outside border to closestt LAN: 
#### Reassign the NAs to the proper regions.
new_DF <- SwedenLocsUTM[is.na(SwedenLocsUTM$LAN_NAMN),]
## visually determine which lan to assign the 3 NA points
plot(SwedenUTM["LAN_NAMN"], key=NULL, reset=FALSE)
plot(SwedenLocsUTM["LAN_NAMN"], add=TRUE, col=1, cex=2)

## Need to use unique IDs created above in the "Identify" column.
## (357396.7 6658404) = V?rmland / (795157.7 7613721) = Norrbottenen / (460042.6 6434811)= J?nk?ping
SwedenLocsUTM[is.na(SwedenLocsUTM$LAN_NAMN),]
SwedenLocsUTM$LAN_NAMN[SwedenLocsUTM$level2pop=="NOR.6.10_1"] <- "V?rmlands l?n"
SwedenLocsUTM$LAN_NAMN[SwedenLocsUTM$level2pop=="FIN.2.1_1"] <- "Norrbottens l?n"
SwedenLocsUTM$LAN_NAMN[SwedenLocsUTM$level2pop=="SWE.7.5_1"] <- "J?nk?pings l?n"


BirdDataUTM[is.na(BirdDataUTM$LAN_NAMN),]
BirdDataUTM$LAN_NAMN[BirdDataUTM$level2pop=="NOR.6.10_1"] <- "V?rmlands l?n"
BirdDataUTM$LAN_NAMN[BirdDataUTM$level2Name=="Lapland"] <- "Norrbottens l?n"
BirdDataUTM$LAN_NAMN[BirdDataUTM$level2pop=="SWE.7.5_1"] <- "J?nk?pings l?n"


## Grouping Lans L so that LANS with few surveys are clustered by proximity. 
## Done manually.  ####

# Combine Blekinge l?n + Kronobergs l?n
BirdDataUTM$NAMECOMBINED <- sub("Blekinge l?n|Kronobergs l?n", "Blekinge l?n + Kronobergs l?n", BirdDataUTM$LAN_NAMN)


## Cleaning Data & Plotting Population Dynamics ####

## Make aggregated bird data wide ####
BirdDataAggWide <- spread(BirdDataAgg, key=year, value=count)

## Remove locations where, per species, there are fewer than 200 individuals observed across all years.
BirdDataAggWide$total <- rowSums(BirdDataAggWide[3:26], na.rm=TRUE)
BirdDataAggWide <- BirdDataAggWide[BirdDataAggWide[,27] >= 200, ]
BirdDataAggWide <- subset(BirdDataAggWide, select = -c(total))

## Removing all species per population where there are more than 5 years with missing data (NAs).
BirdDataAggWideSubset <- BirdDataAggWide[rowSums(is.na(BirdDataAggWide)) <= 5, ]

## Removing species more than 5 population locations across all years.
BirdDataAggWideSubset <- as.data.frame(BirdDataAggWideSubset %>% group_by(species) %>%  filter(n() > 10) %>% ungroup())
## removing rows where species is NA
BirdDataAggWideSubset <-  BirdDataAggWideSubset[!(is.na(BirdDataAggWideSubset$species) | BirdDataAggWideSubset$species==""), ]

unique.species.subset <- unique(BirdDataAggWideSubset$species)
unique.species.subset_numbered<- 1:length(unique.species.subset)
names(unique.species.subset_numbered) <- unique.species.subset


### Calculating Synchrony ####
# use only lans with more than 1 sampling points
npoints <- table(BirdDataAggWideSubset$NAMECOMBINED)
subset <- npoints[npoints>1]
BirdLocsSubset <- SwedenLocsUTM[SwedenLocsUTM$NAMECOMBINED%in%names(subset),]
BirdDataAggSubset <- BirdDataAggWideSubset[BirdDataAggWideSubset$NAMECOMBINED%in%names(subset),]

Coords <- aggregate(st_coordinates(BirdLocsSubset), 
                    by=list(NAMECOMBINED=data.frame(BirdLocsSubset)[,"NAMECOMBINED"]), FUN=mean)
distmat <- dist(Coords[,c("X", "Y")], upper=TRUE)/1000

# A list of some bird species. Preliminary visual exploration of data, selected species which had >8 locations
Species <- unique.species.subset


### Before running analyses, need to standardize species names so they match across datasets ############
## Corvus cornix -> Corvus corone
Species[Species == "Corvus cornix"] <- "Corvus corone"
BirdDataAggSubset$species[BirdDataAggSubset$species == "Corvus cornix"] <- "Corvus corone"

## Linaria cannabina -> Carduelis cannabina
Species[Species == "Linaria cannabina"] <- "Carduelis cannabina"
BirdDataAggSubset$species[BirdDataAggSubset$species == "Linaria cannabina"] <- "Carduelis cannabina"

## Coloeus monedula -> Corvus monedula
Species[Species == "Coloeus monedula"] <- "Corvus monedula"
BirdDataAggSubset$species[BirdDataAggSubset$species == "Coloeus monedula"] <- "Corvus monedula"

## Phylloscopus sibillatrix -> Phylloscopus sibilatrix
Species[Species == "Phylloscopus sibillatrix"] <- "Phylloscopus sibilatrix"
BirdDataAggSubset$species[BirdDataAggSubset$species == "Phylloscopus sibillatrix"] <- "Phylloscopus sibilatrix"

BirdDataAggSubset<-BirdDataAggSubset[!(BirdDataAggSubset$species=="Alauda arvensis"),]

## Removing first ten years of surveys. Poorly surveyed in the North and inconsistent survey protocol. Similar methods for TOVE data.
names(BirdDataAggSubset)[names(BirdDataAggSubset) == "2007"] <- "X2007"
names(BirdDataAggSubset)[names(BirdDataAggSubset) == "2008"] <- "X2008"
names(BirdDataAggSubset)[names(BirdDataAggSubset) == "2009"] <- "X2009"
names(BirdDataAggSubset)[names(BirdDataAggSubset) == "2010"] <- "X2010"
names(BirdDataAggSubset)[names(BirdDataAggSubset) == "2011"] <- "X2011"
names(BirdDataAggSubset)[names(BirdDataAggSubset) == "2012"] <- "X2012"
names(BirdDataAggSubset)[names(BirdDataAggSubset) == "2013"] <- "X2013"
names(BirdDataAggSubset)[names(BirdDataAggSubset) == "2014"] <- "X2014"
names(BirdDataAggSubset)[names(BirdDataAggSubset) == "2015"] <- "X2015"
names(BirdDataAggSubset)[names(BirdDataAggSubset) == "2016"] <- "X2016"
names(BirdDataAggSubset)[names(BirdDataAggSubset) == "2017"] <- "X2017"
names(BirdDataAggSubset)[names(BirdDataAggSubset) == "2018"] <- "X2018"
names(BirdDataAggSubset)[names(BirdDataAggSubset) == "2019"] <- "X2019"

## Remove first 10 years of survey data
BirdDataAggSubset = subset(BirdDataAggSubset, select = -c(3:13) )


## Set up the synchrony analysis tables and lists:

SyncData <- BirdDataAggSubset[BirdDataAggSubset$species%in%Species,] # check for the exclusion of poor sampling years
SyncDataList <- split(SyncData, f=list(
  SyncData$species, SyncData$NAMECOMBINED), drop=TRUE)

SyncDataList <- lapply(SyncDataList, function(x) 
  reshape(x, direction="long", varying=list(3:15), sep=""))

SyncDataList <- lapply(SyncDataList, function(x) 
  cbind.data.frame(x, log.abundance=ifelse((is.na(x$X)|x$X==0), NA, log(x$X))))

SyncDataList <- lapply(SyncDataList, function(x) 
  cbind.data.frame(x, log.r1=append(NA, diff(log(x$X))))) 

SyncDataList <- lapply(SyncDataList, function(x) 
  cbind.data.frame(x, log.r=ifelse(is.na(x$log.r1)|is.nan(x$log.r1)|is.infinite(x$log.r1), NA, x$log.r1)))


SyncDataList <- do.call(rbind.data.frame, SyncDataList)
SyncDataList <- split(SyncDataList, f=SyncDataList$species)

# make wide format
SyncDataLogAb <- lapply(SyncDataList, function(x) 
  reshape(x[,c("time", "NAMECOMBINED", "log.abundance")], direction="wide", 
          idvar="time", timevar="NAMECOMBINED"))
SyncDataLogAb <- lapply(SyncDataLogAb, function(x) 
  scale(x[apply(x, 1, function(y) sum(!is.na(y))>1),-c(1)]))

SyncDatalogr <- lapply(SyncDataList, function(x) 
  reshape(x[,c("time", "NAMECOMBINED", "log.r")], direction="wide", 
          idvar="time", timevar="NAMECOMBINED"))
SyncDatalogr <- lapply(SyncDatalogr, function(x) 
  scale(x[apply(x, 1, function(y) sum(!is.na(y))>1),-c(1)]))


SyncLists <- list(log.abundance=SyncDataLogAb, 
                  log.r=SyncDatalogr)

spdata <- Coords
spdataCoord <- spdata[order(spdata$NAMECOMBINED),]
disttab <- as.matrix(dist(spdataCoord[,2:3], upper=TRUE, diag=FALSE)/1000) # divide with 1000 to get km
colnames(disttab) <- spdataCoord$NAMECOMBINED
rownames(disttab) <- spdataCoord$NAMECOMBINED



### Make separate loop here to calculate mean synchrony at distances of 350km, 1000km, and 500km.
SpeciesMeanbyDistance<-data.frame(nameeg=character(0), Mean1000ab=numeric(0), Mean500ab=numeric(0),
                                  Mean350ab=numeric(0), Mean1000r=numeric(0), Mean500r=numeric(0), 
                                  Mean350r=numeric(0), NumCorr1000=numeric(0), NumCorr500=numeric(0), 
                                  NumCorr350=numeric(0), MeanRawab=numeric(0), MeanRawr = numeric(0))
for(i in 1:length(Species))
{
  sp <- Species[i]
  synchdatawide <- SyncLists[["log.abundance"]][[sp]]
  cormat <- rcorr(synchdatawide)
  cormat$r
  meanrawab<-mean(cormat$r[disttab<4000], na.rm=TRUE)
  mean1000ab<-mean(cormat$r[disttab<1000], na.rm=TRUE) 
  mean500ab<-mean(cormat$r[disttab<500], na.rm=TRUE) 
  mean350ab<-mean(cormat$r[disttab<350], na.rm=TRUE)
  
  synchdatawider <- SyncLists[["log.r"]][[sp]]
  cormatr <- rcorr(synchdatawider)
  ## (sum(!is.na(cormatr$r))-15) tells number of pairwise correlations used to calculate meancorr
  ## cormatr$n tells the number of pairwise correlations used to calculate the meancorr 
  meanrawr<-mean(cormatr$r[disttab<4000], na.rm=TRUE)
  mean1000r<-mean(cormatr$r[disttab<1000], na.rm=TRUE) 
  disttab1000 <- disttab<1000
  disttab1000 <- length(disttab1000[disttab1000 == TRUE])
  mean500r<-mean(cormatr$r[disttab<500], na.rm=TRUE) 
  disttab500 <- disttab<500
  disttab500 <- length(disttab500[disttab500 == TRUE])
  mean350r<-mean(cormatr$r[disttab<350], na.rm=TRUE)
  disttab350 <- disttab<350
  disttab350 <- length(disttab350[disttab350 == TRUE])
  
  newrow<- data.frame(nameeg = as.character(sp), Mean1000ab = mean1000ab,   
                      Mean500ab = mean500ab,   
                      Mean350ab = mean350ab, Mean1000r = mean1000r, Mean500r = mean500r, Mean350r = mean350r,
                      NumCorr1000 = disttab1000, NumCorr500 = disttab500, NumCorr350 = disttab350, 
                      MeanRawab = meanrawab, MeanRawr = meanrawr) 
  
  SpeciesMeanbyDistance <- rbind(SpeciesMeanbyDistance, newrow)              # Apply rbind function
  
} 




SynchTab <- expand.grid(StartRho0=c(0.2,0.4,0.6,0.8), 
                        StartRhoInf=c(0,0.2,0.4,0.6), 
                        StartLambda=log(c(10,20,40,80,160,320, 1000)), 
                        species=Species, 
                        SynchVar=c("log.abundance", "log.r"), 
                        MaxLik=NA,
                        rho.0=NA, rho.inf=NA, Lambda=NA, MeanRhos=NA, N.areas=NA,
                        stringsAsFactors=FALSE)

SynchTab <- SynchTab[SynchTab$StartRho0>=SynchTab$StartRhoInf,] # starting values for rho0 always greater than rhoinf

for(i in 1:nrow(SynchTab))
{
  start <- SynchTab[i,c("StartRho0", "StartRhoInf", "StartLambda")]
  
  sp <- SynchTab[i,"species"]
  svar <- SynchTab[i,"SynchVar"]
  
  synchdatawide <- SyncLists[[svar]][[sp]]
  areas <- substr(colnames(synchdatawide), nchar(svar)+2, nchar(colnames(synchdatawide))) # need to get the names of areas with data, not all areas have all birds
  disttab2 <- disttab[areas, areas] #distance matrix must have same number of row and columns as number of areas
  gausssynch <- optim(start, GaussSyncF, distmat=disttab2, x=synchdatawide)
  gausssynchFix <- optimize(GaussSyncFFix, c(-1,1), distmat=disttab2, x=synchdatawide)
  SynchTab[i,"MaxLik"] <- gausssynch$value
  SynchTab[i,"rho.0"] <- exp(gausssynch$par[1])/(1+exp(gausssynch$par[1]))
  SynchTab[i,"rho.inf"] <- SynchTab[i,"rho.0"]*exp(gausssynch$par[2])/(1+exp(gausssynch$par[2]))
  SynchTab[i,"Lambda"] <- exp(gausssynch$par[3])
  SynchTab[i,"MeanRhos"] <- gausssynchFix$minimum
  SynchTab[i,"N.areas"] <- length(areas)
  print(paste(i, "of", nrow(SynchTab)))
  flush.console()
}
save(SynchTab, file="SynchTab_Sweden.rda")
load("SynchTab_Sweden.rda")


synchtabb <- with(SynchTab, tapply(MaxLik, list(species, SynchVar), min))
SynchTabB <- SynchTab[SynchTab$MaxLik%in%synchtabb,]
SynchTabB<-distinct(SynchTabB,species, SynchVar, .keep_all=TRUE)
SynchTabB['Dataset'] = 'Sweden'


## Load the life history trait data ####
## Combining generation length column with species name:
## Migration classification available from: Eyres, A., K. Bohning-Gaese, and S. A. Fritz. 2017. Quantification of climatic niches in birds: adding the temporal dimension. Journal of Avian Biology 48:1517-1531.
## Generation time data available from: Bird, J. P., R. Martin, H. R. Akçakaya, J. Gilroy, I. J. Burfield, S. T. Garnett, A. Symes, J. Taylor, Ç. H. Şekercioğlu, and S. H. M. Butchart. 2020. Generation lengths of the world`s birds and their implications for extinction risk. Conservation Biology 34:1252-1261.
Migrant <- read.csv("C:\\Users\\ellencm\\NTNU\\Ellen C. Martin PhD - General\\PAPER II\\Trait Data\\LifeHistory_ForPublication.csv")
head(Migrant)


MigData <- Migrant %>%
  select(c(commonname, nameeg))

## Sweden_Mig_Classification is column of manually entered migration classification per species
## Sweden_Mig_Classifications come from MoveBank.org.
SwedenMigClassification <- Migrant %>%
  select(c(nameeg, Sweden_Mig_Classification))

### Match species with generation time 
GenerationTime_Avian_ConsBio <- read.csv("C:\\Users\\ellencm\\NTNU\\Ellen C. Martin PhD - General\\PAPER II\\Trait Data\\GenerationTime_AvianDatabase_Bird_et_al_2020.csv")
Gen.Length <-  GenerationTime_Avian_ConsBio %>%
  select(c(nameeg, GenLength))

MigData <- merge(MigData, Gen.Length, by = "nameeg")
MigData2 <- merge(MigData, SwedenMigClassification, by = "nameeg")

## rename Sweden specific classification column:
names(MigData2)[names(MigData2) == "Sweden_Mig_Classification"] <- "CountrySpecificCat"
## Join the migratory status of each species as new column to SynchTabB object ##
SynchTabMigMerge <- merge(SynchTabB, MigData2, by="nameeg")
## Join the mean rho by distance as a new column to SynchTabB object
SynchTabMigMerge2<- merge(SynchTabMigMerge, SpeciesMeanbyDistance, by = "nameeg") ## IF USING MEAN BY DISTANCE
## Remove duplicated species 
SynchTabMigMerge2 <- SynchTabMigMerge2 [!duplicated(SynchTabMigMerge2[c(1,5,6)]),]

save(SynchTabMigMerge2, file="SWEDEN_COUNTRYSPECIFIC_SYNCH.rda")

################## UNITED KINGROM
##############
## UK Breeding Bird survey
## Data from 1996 - 2015 British Trust for Ornithology [data request REF1599224671889842]
## Provided by Dario Massimo on 12 11 2021 
## Updated 26 10 2022 

## Load packages
library(dplyr)
library(reshape2)
library(tidyr)
library(ggplot2)
library(tidyverse)
library(geosphere)
library(sf)
library(mapsf)
library(rgdal)
library(mvtnorm)
library(RColorBrewer)
library(dplyr)
library(data.table)
library(Hmisc)
library(tidyr)
library(dplyr)

## Define functions for estimating synchrony ####
GaussSyncE <- function(rho.0, rho.inf, x, lambda) (rho.0-rho.inf)*exp(-(x^2)/(2*lambda^2)) + rho.inf #Sjekk parantesen i siste term
ExpSyncE <- function(rho.0, rho.inf, x, lambda) (rho.0-rho.inf)*exp(-x/lambda) + rho.inf # Sjekk parantesen i siste term

GaussSyncF <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  rho.0 <- exp(par[1])/(1+exp(par[1]))
  rho.inf <- rho.0*exp(par[2])/(1+exp(par[2]))          
  lambda <- exp(par[3])
  if (startVal){
    cat(round(c(rho.0, rho.inf, lambda)),3)
  }
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- (rho.0-rho.inf)*exp(-(distmatsel^2)/(2*lambda^2)) + rho.inf
    diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}
GaussSyncFboot <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  rho.0 <- exp(par[1])/(1+exp(par[1]))
  rho.inf <- rho.0*exp(par[2])/(1+exp(par[2]))          
  lambda <- exp(par[3])
  if (startVal){
    cat(round(c(rho.0, rho.inf, lambda)),3)
  }
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- (rho.0-rho.inf)*exp(-(distmatsel^2)/(2*lambda^2)) + rho.inf
    #diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}

GaussSyncFFix <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- matrix(par, nr=sum(sel), nc=sum(sel))
    diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}
ExpSyncF <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  rho.0 <- exp(par[1])/(1+exp(par[1]))
  rho.inf <- rho.0*exp(par[2])/(1+exp(par[2]))          
  lambda <- exp(par[3])
  if (startVal){
    cat(round(c(rho.0, rho.inf, lambda)),3)
  }
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- (rho.0-rho.inf)*exp(-distmatsel/lambda) + rho.inf
    diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}


## Importing and formatting United Kingdom BBS data  ####################################################################################################
## Data imported from Dario Massimo, British Trust for Ornithology [data request REF1599224671889842]
## Data accessed 12/11/2021

BBScounts <- read.csv("C:/Users/ellencm/NTNU/Ellen C. Martin PhD - General/Paper II/UK/Raw Data/bbsdr-9415-UK.csv") ## Raw counts per survey area
names <-  read.csv("C:/Users/ellencm/NTNU/Ellen C. Martin PhD - General/Paper II/UK/Raw Data/two_letter_codes.csv") ## Two letter bird identification codes
names(BBScounts)[3]<-"Two_letter_code"
squares <- read.csv("C:/Users/ellencm/NTNU/Ellen C. Martin PhD - General/Paper II/UK/Raw Data/all_squares_X_years_9415.csv") ## Squares surveyed each year
squarelatlong <- read.csv("C:/Users/ellencm/NTNU/Ellen C. Martin PhD - General/Paper II/UK/Raw Data/BritishIslesLatLongCentroidsOfOneKM.csv") ## British Isles Centroid of surveyed squares (lat/long)
names(squarelatlong)[1]<-"square"

## Merge Lat long centroid locations to survey unit file
BirdLocs <- merge(squares, squarelatlong, by='square')
BirdLocsAll <- BirdLocs[,-2] ## remove year from dataframe
UniqueBirdLocs <- BirdLocsAll %>% distinct(square, .keep_all=TRUE)

## Adding English and Latin names to count dataframe
WorkingData <-merge(BBScounts, names,by=c('Two_letter_code'),all.x=T)
Data <-WorkingData[,-1] ## Remove column of two-letter-code of bird name.


## Define projections for sf objects. Layers are ETRS and BNG: want to transform to UTM33
ETRSproj = "+init=epsg:4258"
BNGproj = "+init=epsg:27700" ## Region boundaries in British national grid projection
UTM33proj <- "+proj=utm +zone=33 +datum=WGS84"


## Load the NUTS1 shapefile (statistical regions) for UK
## NUTS1 shapefile available at:  https://geoportal.statistics.gov.uk/datasets/nuts-level-1-january-2018-full-clipped-boundaries-in-the-united-kingdom
UK_NUTS1 <- sf::st_read(dsn="NUTS_Level_1_Boundaries", 
                        layer="NUTS_Level_1_(January_2018)_Boundaries")
colnames(UK_NUTS1)[3] <- "NAME"
UK <- UK_NUTS1[,"NAME"]
UK <- UK[!UK$NAME%in%c("Scotland", "Northern Ireland"),]  ## Remove Scotland to replace with smaller NUTS2 counties

## Load the NUTS2 shapefile (counties or council areas) for subdivision of Scotland
NUTS2Boundaries <- sf::st_read(dsn="NUTS_Level_2_Boundaries", 
                               layer="NUTS_Level_2_(January_2018)_Boundaries")
Scotland <- NUTS2Boundaries[NUTS2Boundaries$nuts218nm%in%c("Highlands and Islands", "North Eastern Scotland", 
                                                           "Eastern Scotland", "Northern Ireland", 
                                                           "Southern Scotland", "West Central Scotland"),]
colnames(Scotland)[3] <- "NAME"
Scotland2 <- Scotland[,"NAME"]

## Combine UK NUTS1 with Scotland NUTS2 
UK_Scotland_Merge <- rbind(Scotland2, UK)

## Define projections for sf objects.
UK_Scotland_Merge <- st_transform(UK_Scotland_Merge, crs=ETRSproj) ## Transform combined sf object into ETRS projection.
UTM33proj <- "+proj=utm +zone=33 +datum=WGS84"
UK_Scotland_MergeUTM <- st_transform(UK_Scotland_Merge, crs=UTM33proj)


## Make the bird square data sf objects, transform to correct crs (lonlatproj)
BirdLocsUTM <- st_as_sf(x=UniqueBirdLocs, coords=c("ETRS89Long", "ETRS89Lat"), crs=ETRSproj)


## Spatial overlay to assign points to regions/counties ####
pointsinkanton <- st_intersects(BirdLocsUTM, UK_Scotland_Merge)
KantonID <- unlist(lapply(pointsinkanton, function(x) ifelse(length(x)==0, NA, as.vector(UK_Scotland_Merge$NAME)[x])))
BirdLocsUTM[,"NAME"] <- KantonID

# Merge with location data to get the regions/counties
BirdData <- merge(Data, data.frame(BirdLocsUTM), by="square")

# Aggregate the counts by the regions/counties (NAME)
BirdDataAgg <- aggregate(count~NAME+Scientific_name+year, data=BirdData, 
                         FUN=function(x) sum(x, na.rm=TRUE))
BirdDataAggWide <- spread(BirdDataAgg, key=year, value=count) ## Transform the dataframe to a wide format

unique.species <- unique(BirdDataAgg$Scientific_name)
unique.species_numbered <- 1:length(unique.species)
names(unique.species_numbered) <- unique.species


## Calculate averages ######################################################################################
widetable <- as.data.frame(t(table))
widetable <- cbind(rownames(widetable),widetable)
rownames(widetable) <- NULL
colnames(widetable) <- c(names(widetable)) #to not write all the column names
colnames(widetable)[1] <- "NAME" 
names(widetable)
year <- "year"
numbersites <- "numbersites"
gathercols <- c("1994", "1995", "1996", "1997","1998","1999","2000","2002","2003","2004","2005","2006","2007","2008","2009","2010","2011","2012","2013","2014","2015")
longtable<- tidyr::gather(widetable, year, numbersites, gathercols)

BirdDataAggoffset <- BirdDataAgg %>%
  mutate(year = as.character(year)) %>% 
  left_join(longtable) 

BirdDataAggoffset$offset <- with(BirdDataAggoffset, count/numbersites)

BirdDataAggWideoffset <- subset(BirdDataAggoffset, select = -c(count, numbersites))
BirdDataAggWideoffset<- reshape(BirdDataAggWideoffset, idvar = c("NAME","Scientific_name"), timevar = "year", direction = "wide")
names(BirdDataAggWideoffset)[3:ncol(BirdDataAggWideoffset)] <- c("1994", "1995", "1996", "1997", "1998", "1999", "2000", "2002", "2003", "2004", "2005", "2006","2007", "2008", "2009", "2010", "2011", "2012", "2013","2014","2015")

names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "1994"] <- "X1994"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "1995"] <- "X1995"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "1996"] <- "X1996"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "1997"] <- "X1997"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "1998"] <- "X1998"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "1999"] <- "X1999"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2000"] <- "X2000"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2002"] <- "X2002"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2003"] <- "X2003"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2004"] <- "X2004"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2005"] <- "X2005"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2006"] <- "X2006"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2007"] <- "X2007"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2008"] <- "X2008"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2009"] <- "X2009"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2010"] <- "X2010"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2011"] <- "X2011"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2012"] <- "X2012"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2013"] <- "X2013"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2014"] <- "X2014"
names(BirdDataAggWideoffset)[names(BirdDataAggWideoffset) == "2015"] <- "X2015"

matplot(rownames(table), table, xlab="Year", 
        ylab="# Locations Surveyed", type="l", lty=1, pch=19, main="UK Survey Squares per NUT1 Region per Year")


## Cleaning Data & Plotting Population Dynamics ####
## Convert everything to UTM
UK_Scotland_Merge_UTM <- st_transform(UK_Scotland_Merge, crs=UTM33proj)
BirdLocsUTM <- st_transform(BirdLocsUTM, crs=UTM33proj)
Coords <- aggregate(st_coordinates(BirdLocsUTM), 
                    by=list(NAME=data.frame(BirdLocsUTM)[,"NAME"]), FUN=mean)
distmat <- dist(Coords[,c("X", "Y")], upper=TRUE)/1000
Species = unique.species

### Before running analyses, need to standardize species names so they match across datasets ############
## Corvus cornix -> Corvus corone
Species[Species == "Corvus cornix"] <- "Corvus corone"
BirdDataAgg$Scientific_name[BirdDataAgg$Scientific_name == "Corvus cornix"] <- "Corvus corone"

## Linaria cannabina -> Carduelis cannabina
Species[Species == "Linaria cannabina"] <- "Carduelis cannabina"
BirdDataAgg$Scientific_name[BirdDataAgg$Scientific_name ==  "Linaria cannabina"] <- "Carduelis cannabina"

## Coloeus monedula -> Corvus monedula
Species[Species == "Coloeus monedula"] <- "Corvus monedula"
BirdDataAgg$Scientific_name[BirdDataAgg$Scientific_name ==  "Coloeus monedula"] <- "Corvus monedula"

## Phylloscopus sibillatrix -> Phylloscopus sibilatrix
Species[Species == "Phylloscopus sibillatrix"] <- "Phylloscopus sibilatrix"
BirdDataAgg$Scientific_name[BirdDataAgg$Scientific_name ==  "Phylloscopus sibillatrix"] <- "Phylloscopus sibilatrix"



## Set up the synchrony analysis tables and lists:
SyncData <- BirdDataAggWideoffset[BirdDataAggWideoffset$Scientific_name%in%Species,] # check for the exclusion of poor sampling years
SyncDataList <- split(SyncData, f=list(
  SyncData$Scientific_name, SyncData$NAME), drop=TRUE)
SyncDataList <- lapply(SyncDataList, function(x) 
  reshape(x, direction="long", varying=3:ncol(SyncData), sep=""))

SyncDataList <- lapply(SyncDataList, function(x) 
  cbind.data.frame(x, log.abundance=ifelse((is.na(x$X)|x$X==0), NA, log(x$X))))
SyncDataList <- lapply(SyncDataList, function(x) 
  cbind.data.frame(x, log.r1=append(NA, diff(log(x$X))))) 
SyncDataList <- lapply(SyncDataList, function(x) 
  cbind.data.frame(x, log.r=ifelse(is.na(x$log.r1)|is.nan(x$log.r1)|is.infinite(x$log.r1), NA, x$log.r1)))

SyncDataList <- do.call(rbind.data.frame, SyncDataList)
SyncDataList <- split(SyncDataList, f=SyncDataList$Scientific_name)

# make wide format
SyncDataLogAb <- lapply(SyncDataList, function(x) 
  reshape(x[,c("time", "NAME", "log.abundance")], direction="wide", 
          idvar="time", timevar="NAME"))
SyncDataLogAb <- lapply(SyncDataLogAb, function(x) 
  scale(x[apply(x, 1, function(y) sum(!is.na(y))>1),-c(1)]))

SyncDatalogr <- lapply(SyncDataList, function(x) 
  reshape(x[,c("time", "NAME", "log.r")], direction="wide", 
          idvar="time", timevar="NAME"))
SyncDatalogr <- lapply(SyncDatalogr, function(x) 
  scale(x[apply(x, 1, function(y) sum(!is.na(y))>1),-c(1)]))


SyncLists <- list(log.abundance=SyncDataLogAb, 
                  log.r=SyncDatalogr)

spdata <- Coords
spdataCoord <- spdata[order(spdata$NAME),]
disttab <- as.matrix(dist(spdataCoord[,2:3], upper=TRUE, diag=FALSE)/1000) # divide with 1000 to get km
colnames(disttab) <- spdataCoord$NAME
rownames(disttab) <- spdataCoord$NAME

### Make separate loop here to calculate mean synchrony at distances of 350km, 1000km, and 500km.
SpeciesMeanbyDistance<-data.frame(nameeg=character(0), Mean1000ab=numeric(0), Mean500ab=numeric(0),
                                  Mean350ab=numeric(0), Mean1000r=numeric(0), Mean500r=numeric(0), 
                                  Mean350r=numeric(0), NumCorr1000=numeric(0), NumCorr500=numeric(0), 
                                  NumCorr350=numeric(0), MeanRawab=numeric(0), MeanRawr = numeric(0))
for(i in 1:length(Species))
{
  sp <- Species[i]
  synchdatawide <- SyncLists[["log.abundance"]][[sp]]
  cormat <- rcorr(synchdatawide)
  cormat$r
  meanrawab<-mean(cormat$r[disttab<4000], na.rm=TRUE)
  mean1000ab<-mean(cormat$r[disttab<1000], na.rm=TRUE) 
  mean500ab<-mean(cormat$r[disttab<500], na.rm=TRUE) 
  mean350ab<-mean(cormat$r[disttab<350], na.rm=TRUE)
  
  synchdatawider <- SyncLists[["log.r"]][[sp]]
  cormatr <- rcorr(synchdatawider)
  ## (sum(!is.na(cormatr$r))-15) tells number of pairwise correlations used to calculate meancorr
  ## cormatr$n tells the number of pairwise correlations used to calculate the meancorr 
  meanrawr<-mean(cormatr$r[disttab<4000], na.rm=TRUE)
  mean1000r<-mean(cormatr$r[disttab<1000], na.rm=TRUE) 
  disttab1000 <- disttab<1000
  disttab1000 <- length(disttab1000[disttab1000 == TRUE])
  mean500r<-mean(cormatr$r[disttab<500], na.rm=TRUE) 
  disttab500 <- disttab<500
  disttab500 <- length(disttab500[disttab500 == TRUE])
  mean350r<-mean(cormatr$r[disttab<350], na.rm=TRUE)
  disttab350 <- disttab<350
  disttab350 <- length(disttab350[disttab350 == TRUE])
  
  newrow<- data.frame(nameeg = as.character(sp), Mean1000ab = mean1000ab,   
                      Mean500ab = mean500ab,   
                      Mean350ab = mean350ab, Mean1000r = mean1000r, Mean500r = mean500r, Mean350r = mean350r,
                      NumCorr1000 = disttab1000, NumCorr500 = disttab500, NumCorr350 = disttab350, 
                      MeanRawab = meanrawab, MeanRawr = meanrawr) 
  
  SpeciesMeanbyDistance <- rbind(SpeciesMeanbyDistance, newrow)              # Apply rbind function
  
} 






SynchTab <- expand.grid(StartRho0=c(0.2,0.4,0.6,0.8), 
                        StartRhoInf=c(0,0.2,0.4,0.6), 
                        StartLambda=log(c(10,20,40,80,160,320, 1000)), 
                        nameeg=Species, 
                        SynchVar=c("log.abundance", "log.r"), 
                        MaxLik=NA,
                        rho.0=NA, rho.inf=NA, Lambda=NA, MeanRhos=NA, N.areas=NA,
                        stringsAsFactors=FALSE)

SynchTab <- SynchTab[SynchTab$StartRho0>=SynchTab$StartRhoInf,] # starting values for rho0 always greater than rhoinf

if (Sys.info()["login"] == "ellencm"){
  setwd("C:\\Users\\ellencm\\NTNU\\Ellen C. Martin PhD - General\\PAPER II\\UK")
}
getwd()

for(i in 1:nrow(SynchTab))
{
  start <- SynchTab[i,c("StartRho0", "StartRhoInf", "StartLambda")]
  
  sp <- SynchTab[i,"nameeg"]
  svar <- SynchTab[i,"SynchVar"]
  synchdatawide <- SyncLists[[svar]][[sp]]
  areas <- substr(colnames(synchdatawide), nchar(svar)+2, nchar(colnames(synchdatawide))) # need to get the names of areas with data, not all areas have all birds
  disttab2 <- disttab[areas, areas] #distance matrix must have same number of row and columns as number of areas
  gausssynch <- optim(start, GaussSyncF, distmat=disttab2, x=synchdatawide)
  gausssynchFix <- optimize(GaussSyncFFix, c(-1,1), distmat=disttab2, x=synchdatawide)
  SynchTab[i,"MaxLik"] <- gausssynch$value
  SynchTab[i,"rho.0"] <- exp(gausssynch$par[1])/(1+exp(gausssynch$par[1]))
  SynchTab[i,"rho.inf"] <- SynchTab[i,"rho.0"]*exp(gausssynch$par[2])/(1+exp(gausssynch$par[2]))
  SynchTab[i,"Lambda"] <- exp(gausssynch$par[3])
  SynchTab[i,"MeanRhos"] <- gausssynchFix$minimum
  SynchTab[i,"N.areas"] <- length(areas)
  print(paste(i, "of", nrow(SynchTab)))
  flush.console()
}
save(SynchTab, file="SynchTab_UKBBS_OFFSET_28052022.rda")
load("SynchTab_UKBBS_OFFSET_28052022.rda")

synchtabb <- with(SynchTab, tapply(MaxLik, list(nameeg, SynchVar), min))
SynchTabB <- SynchTab[SynchTab$MaxLik%in%synchtabb,]
SynchTabB['Dataset'] = 'UK Offset'
## removes duplicates with MaxLik values
SynchTabB<-distinct(SynchTabB,nameeg,MaxLik, SynchVar, .keep_all=TRUE)
save(SynchTabB, file="SynchTab_UK_AVERAGE.rda")

##################### NORWAY
##############
## NORWAY TOV-E Breeding Bird survey
## Data provided: June 2021, GBIF [https://doi.org/10.15468/6jmw2e] & John Atle Kalas/NINA [personal communication]
## Updated 26 10 2022

## Load packages
library(dplyr)
library(reshape2)
library(tidyr)
library(ggplot2)
library(tidyverse)
library(geosphere)
library(sf)
library(mapsf)
library(rgdal)
library(mvtnorm)
library(RColorBrewer)
library(dplyr)
library(data.table)
library(Hmisc)


## Define functions for estimating synchrony ####
GaussSyncE <- function(rho.0, rho.inf, x, lambda) (rho.0-rho.inf)*exp(-(x^2)/(2*lambda^2)) + rho.inf 
ExpSyncE <- function(rho.0, rho.inf, x, lambda) (rho.0-rho.inf)*exp(-x/lambda) + rho.inf 

GaussSyncF <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  rho.0 <- exp(par[1])/(1+exp(par[1]))
  rho.inf <- rho.0*exp(par[2])/(1+exp(par[2]))          
  lambda <- exp(par[3])
  if (startVal){
    cat(round(c(rho.0, rho.inf, lambda)),3)
  }
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- (rho.0-rho.inf)*exp(-(distmatsel^2)/(2*lambda^2)) + rho.inf
    diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}
GaussSyncFboot <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  rho.0 <- exp(par[1])/(1+exp(par[1]))
  rho.inf <- rho.0*exp(par[2])/(1+exp(par[2]))          
  lambda <- exp(par[3])
  if (startVal){
    cat(round(c(rho.0, rho.inf, lambda)),3)
  }
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- (rho.0-rho.inf)*exp(-(distmatsel^2)/(2*lambda^2)) + rho.inf
    #diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}

GaussSyncFFix <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- matrix(par, nr=sum(sel), nc=sum(sel))
    diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}
ExpSyncF <- function(par, x, distmat, startVal=FALSE){
  # x : standardisert
  
  rho.0 <- exp(par[1])/(1+exp(par[1]))
  rho.inf <- rho.0*exp(par[2])/(1+exp(par[2]))          
  lambda <- exp(par[3])
  if (startVal){
    cat(round(c(rho.0, rho.inf, lambda)),3)
  }
  logLL <- 0
  for (i in 1:nrow(x)){
    xx <- x[i,]
    sel <- !is.na(xx)
    distmatsel <- distmat[sel,sel]
    xx <- xx[sel]
    mu <- rep(0, length(xx))
    sigma <- (rho.0-rho.inf)*exp(-distmatsel/lambda) + rho.inf
    diag(sigma) <- 1
    logLL <- logLL + -sum(dmvnorm(xx, mu, sigma,log = TRUE))
  }
  logLL
}

## Importing and formatting Norway TOV-E Data ####################################################################################################
## Data imported from GBIF, available at:  https://doi.org/10.15468/6jmw2e 
## Data accessed from GBIF on 06/06/2021
## TOV-E_Routes_MidPoint.csv provided by Kålås J.A., NINA, direct communication.

DataFrame <- read.csv("Raw Data/TOVE_Norway.csv", encoding = "UTF-8")
TOVE_Midpoints <- read.csv("Raw Data/TOV-E_Routes_MidPoint.csv", encoding = "UTF-8")

## Select the columns we need for this analysis. 
## These names are based on GBIF nomenclature. 
DataFrameSelected <- DataFrame %>%
  select(c(species, year, organismQuantity,locationID, level0Gid, level1Gid,
           level2Gid, level3Gid,level1Name, level2Name, level3Name, decimalLatitude, decimalLongitude))

## Replace the latitude and longitude in dataframe with the correct midpoint lat lon values from TOVE_Midpoints
names(TOVE_Midpoints)[names(TOVE_Midpoints) == "RUTENR"] <- "locationID"
DataFrameSelected <- merge(DataFrameSelected, TOVE_Midpoints, by="locationID")


## Define projections for sf objects. Layers are EPSG and WGS84: want to transform to UTM33
UTM33proj <- "+proj=utm +zone=33 +datum=WGS84"   ## Projection want to transform into
EPSG4326 <- "+init=epsg:4326"   ## Original data projection
lonlatproj <- "+proj=longlat +unit=dd +datum=WGS84" ## Original data projection

## Import boundaries of grid units for aggreagation (level1)
## Level 1 administrative grid units available for download from Norwegian Mapping Authority: https://www.geoboundaries.org/data/1_3_3/zip/shapefile/NOR/

Level1Gid <- sf::st_read("NorwayLevel1Boundary/NOR_adm1.shp")
Level1Gidtransformed <- st_transform(Level1Gid, crs=UTM33proj) ## Transform into standard UTM33 projection


## Transform bird count data into a sf object
BirdDataSF <- st_as_sf(x=DataFrameSelected, coords=c("decimalLongitude", "decimalLatitude"), crs=EPSG4326)
## There are blanks for level1Name which should be Oslo. Replace them here:
BirdDataSF$level1Name[BirdDataSF$level1Name==""] <- "Oslo"
BirdDataSFtransformed <- st_transform(BirdDataSF, crs=UTM33proj) ## Transform into standard UTM33 projection


## Grouping Level1Gids so that Level1Gids with few surveys are clustered by proximity. 
## Done manually. Do for both the intersection object and the KantonsUTM ####

# Combine ?stfold + Akershus 
BirdDataSFtransformed$NAMECOMBINED <- NA
BirdDataSFtransformed$NAMECOMBINED <- sub("?stfold|Akershus", "?stfold + Akershus", BirdDataSFtransformed$level1Name)
Level1Gidtransformed$NAMECOMBINED <- sub("?stfold|Akershus", "?stfold + Akershus", Level1Gidtransformed$NAME_1)

# Combine Oslo + Buskerud  
BirdDataSFtransformed$NAMECOMBINED <- sub("Oslo|Buskerud", "Oslo + Buskerud", BirdDataSFtransformed$NAMECOMBINED)
Level1Gidtransformed$NAMECOMBINED <- sub("Oslo|Buskerud", "Oslo + Buskerud", Level1Gidtransformed$NAMECOMBINED)

# Combine Vestfold + Telemark   
BirdDataSFtransformed$NAMECOMBINED <- sub("Vestfold|Telemark", "Vestfold + Telemark", BirdDataSFtransformed$NAMECOMBINED)
Level1Gidtransformed$NAMECOMBINED <- sub("Vestfold|Telemark", "Vestfold + Telemark", Level1Gidtransformed$NAMECOMBINED)

# Aggregate counts by NAMECOMBINED level
BirdDataAgg <- aggregate(organismQuantity ~NAMECOMBINED+species+year, data=BirdDataSFtransformed, 
                         FUN=function(x) sum(x, na.rm=TRUE))

# Cantons post-aggregation to be used as new populations:
c <- unique(BirdDataSFtransformed$NAMECOMBINED)


## Aggregate the level1Gids in the spatial dataframe. Merging polygons of the cantons which are added together. 
mergedNorwayLevel1GID <-Level1Gidtransformed %>% 
  group_by(NAMECOMBINED) %>% 
  summarise(geometry = sf::st_union(geometry)) %>% 
  ungroup()


## Cleaning Data & Plotting Population Dynamics ####

## Make aggregated bird data wide ####
BirdDataAggWide <- spread(BirdDataAgg, key=year, value=organismQuantity)

## Remove locations where, per species, there are fewer than 20 individuals observed across all years.
BirdDataAggWide$total <- rowSums(BirdDataAggWide[3:17], na.rm=TRUE)
BirdDataAggWide <- BirdDataAggWide[BirdDataAggWide[,18] >= 20, ]
BirdDataAggWide <- subset(BirdDataAggWide, select = -c(total))

## Removing all species per population where there are more than 5 years with missing data (NAs).
BirdDataAggWideSubset <- BirdDataAggWide[rowSums(is.na(BirdDataAggWide)) <= 5, ]

## Removing species with fewer than 5 population locations across all years.
BirdDataAggWideSubset <- as.data.frame(BirdDataAggWideSubset %>% group_by(species) %>%  filter(n() > 10) %>% ungroup())

## Removing rows where species is NA
BirdDataAggWideSubset <-  BirdDataAggWideSubset[!(is.na(BirdDataAggWideSubset$species) | BirdDataAggWideSubset$species==""), ]

unique.species.subset <- unique(BirdDataAggWideSubset$species)
unique.species.subset_numbered<- 1:length(unique.species.subset)
names(unique.species.subset_numbered) <- unique.species.subset

# Use only counties with more than 1 sampling points
npoints <- table(mergedNorwayLevel1GID$NAMECOMBINED)
subset <- npoints[npoints>0]
BirdLocsSubset <- mergedNorwayLevel1GID[mergedNorwayLevel1GID$NAMECOMBINED%in%names(subset),]
BirdDataAggSubset <- BirdDataAgg[BirdDataAgg$NAMECOMBINED%in%names(subset),]

## If running analysis on specific species, and selecting them manually:
## First make wide
BirdDataAggSubsetWide <- dcast(BirdDataAggSubset, species + NAMECOMBINED ~ year, value.var="organismQuantity", fun.aggregate = sum)

Coords <- as.data.frame(st_coordinates(BirdLocsSubset %>%
                                         group_by(NAMECOMBINED) %>% 
                                         summarize(geometry = st_union(geometry)) %>% 
                                         st_centroid))
rownames <- (BirdLocsSubset$NAMECOMBINED) 
Coords$NAMECOMBINED <- rownames

distmat <- dist(Coords[,c("X", "Y")], upper=TRUE)/1000


Species <- c("Anthus trivialis", "Chloris chloris", "Columba palumbus",
            "Corvus cornix","Cuculus canorus","Emberiza citrinella","Erithacus rubecula",
            "Ficedula hypoleuca","Fringilla coelebs",
            "Lyrurus tetrix","Motacilla alba","Muscicapa striata",
            "Parus major", "Phoenicurus phoenicurus",
            "Phylloscopus collybita","Phylloscopus trochilus","Poecile montanus",
            "Prunella modularis","Spinus spinus",
            "Troglodytes troglodytes", "Turdus iliacus","Turdus merula","Turdus philomelos",
            "Turdus pilaris","Acanthis flammea","Anthus pratensis", 
            "Emberiza schoeniclus",
            "Oenanthe oenanthe", "Turdus torquatus", "Corvus corax",
            "Fringilla montifringilla", "Gallinago gallinago", "Lagopus lagopus",
            "Lagopus muta", "Pluvialis apricaria", "Tringa totanus")



### Before running analyses, need to standardize species names so they match across datasets ############
## Corvus cornix -> Corvus corone
Species[Species == "Corvus cornix"] <- "Corvus corone"
BirdDataAggSubsetWide$species[BirdDataAggSubsetWide$species == "Corvus cornix"] <- "Corvus corone"

## Linaria cannabina -> Carduelis cannabina
Species[Species == "Linaria cannabina"] <- "Carduelis cannabina"
BirdDataAggSubsetWide$species[BirdDataAggSubsetWide$species == "Linaria cannabina"] <- "Carduelis cannabina"

## Coloeus monedula -> Corvus monedula
Species[Species == "Coloeus monedula"] <- "Corvus monedula"
BirdDataAggSubsetWide$species[BirdDataAggSubsetWide$species == "Coloeus monedula"] <- "Corvus monedula"

## Phylloscopus sibillatrix -> Phylloscopus sibilatrix
Species[Species == "Phylloscopus sibillatrix"] <- "Phylloscopus sibilatrix"
BirdDataAggSubsetWide$species[BirdDataAggSubsetWide$species == "Phylloscopus sibillatrix"] <- "Phylloscopus sibilatrix"


## Drop years 2006 - 2008 based on discussing with JA Kalas: Data is not as quality controlled in early years of surveys. 
BirdDataAggSubsetWide <- BirdDataAggSubsetWide[ -c(3:5)]

is.nan.data.frame <- function(x)
       do.call(cbind, lapply(x, is.nan))

BirdDataAggSubsetWide[is.nan(BirdDataAggSubsetWide)] <- NA

SyncData <- BirdDataAggSubsetWide[BirdDataAggSubsetWide$species%in%Species,] # check for the exclusion of poor sampling years

names(SyncData)[names(SyncData) == "2009"] <- "X2009"
names(SyncData)[names(SyncData) == "2010"] <- "X2010"
names(SyncData)[names(SyncData) == "2011"] <- "X2011"
names(SyncData)[names(SyncData) == "2012"] <- "X2012"
names(SyncData)[names(SyncData) == "2013"] <- "X2013"
names(SyncData)[names(SyncData) == "2014"] <- "X2014"
names(SyncData)[names(SyncData) == "2015"] <- "X2015"
names(SyncData)[names(SyncData) == "2016"] <- "X2016"
names(SyncData)[names(SyncData) == "2017"] <- "X2017"
names(SyncData)[names(SyncData) == "2018"] <- "X2018"
names(SyncData)[names(SyncData) == "2019"] <- "X2019"
names(SyncData)[names(SyncData) == "2020"] <- "X2020"


## Set up the synchrony analysis tables and lists:
SyncDataList <- split(SyncData, f=list(
  SyncData$species, SyncData$NAMECOMBINED), drop=TRUE)
SyncDataList <- lapply(SyncDataList, function(x) 
  reshape(x, direction="long", varying=paste0("X", 2009:2020), sep=""))
SyncDataList <- lapply(SyncDataList, function(x) 
  cbind.data.frame(x, log.abundance=ifelse((is.na(x$X)|x$X==0), NA, log(x$X))))
SyncDataList <- lapply(SyncDataList, function(x) 
  cbind.data.frame(x, log.r1=append(NA, diff(log(x$X))))) 
SyncDataList <- lapply(SyncDataList, function(x) 
  cbind.data.frame(x, log.r=ifelse(is.na(x$log.r1)|is.nan(x$log.r1)|is.infinite(x$log.r1), NA, x$log.r1)))


SyncDataList <- do.call(rbind.data.frame, SyncDataList)
SyncDataList <- split(SyncDataList, f=SyncDataList$species)
is.nan.data.frame <- function(x)
  do.call(cbind, lapply(x, is.nan))

SyncDataList <- rapply(SyncDataList, f=function(x) ifelse(is.nan(x),0,x), how="replace")

# make wide format
SyncDataLogAb <- lapply(SyncDataList, function(x) 
  reshape(x[,c("time", "NAMECOMBINED", "log.abundance")], direction="wide", 
          idvar="time", timevar="NAMECOMBINED"))
SyncDataLogAb <- lapply(SyncDataLogAb, function(x) 
  scale(x[apply(x, 1, function(y) sum(!is.na(y))>1),-c(1)]))

SyncDatalogr <- lapply(SyncDataList, function(x) 
  reshape(x[,c("time", "NAMECOMBINED", "log.r")], direction="wide", 
          idvar="time", timevar="NAMECOMBINED"))
SyncDatalogr <- lapply(SyncDatalogr, function(x) 
  scale(x[apply(x, 1, function(y) sum(!is.na(y))>1),-c(1)]))


SyncLists <- list(log.abundance=SyncDataLogAb, 
                  log.r=SyncDatalogr)

spdata <- Coords
spdataCoord <- spdata[order(spdata$NAMECOMBINED),]
disttab <- as.matrix(dist(spdataCoord[,1:2], upper=TRUE, diag=FALSE)/1000) # divide with 1000 to get km
colnames(disttab) <- spdataCoord$NAMECOMBINED
rownames(disttab) <- spdataCoord$NAMECOMBINED


### Make separate loop here to calculate mean synchrony at distances of 350km, 1000km, and 500km.
SpeciesMeanbyDistance<-data.frame(nameeg=character(0), Mean1000ab=numeric(0), Mean500ab=numeric(0),
                                  Mean350ab=numeric(0), Mean1000r=numeric(0), Mean500r=numeric(0), 
                                  Mean350r=numeric(0), NumCorr1000=numeric(0), NumCorr500=numeric(0), 
                                  NumCorr350=numeric(0), MeanRawab=numeric(0), MeanRawr = numeric(0))
for(i in 1:length(Species))
{
  sp <- Species[i]
  synchdatawide <- SyncLists[["log.abundance"]][[sp]]
  cormat <- rcorr(synchdatawide)
  cormat$r
  meanrawab<-mean(cormat$r[disttab<4000], na.rm=TRUE)
  mean1000ab<-mean(cormat$r[disttab<1000], na.rm=TRUE) 
  mean500ab<-mean(cormat$r[disttab<500], na.rm=TRUE) 
  mean350ab<-mean(cormat$r[disttab<350], na.rm=TRUE)

  synchdatawider <- SyncLists[["log.r"]][[sp]]
  cormatr <- rcorr(synchdatawider)
  ## (sum(!is.na(cormatr$r))-15) tells number of pairwise correlations used to calculate meancorr
  ## cormatr$n tells the number of pairwise correlations used to calculate the meancorr 
  meanrawr<-mean(cormatr$r[disttab<4000], na.rm=TRUE)
  mean1000r<-mean(cormatr$r[disttab<1000], na.rm=TRUE) 
  disttab1000 <- disttab<1000
  disttab1000 <- length(disttab1000[disttab1000 == TRUE])
  mean500r<-mean(cormatr$r[disttab<500], na.rm=TRUE) 
  disttab500 <- disttab<500
  disttab500 <- length(disttab500[disttab500 == TRUE])
  mean350r<-mean(cormatr$r[disttab<350], na.rm=TRUE)
  disttab350 <- disttab<350
  disttab350 <- length(disttab350[disttab350 == TRUE])
  
  newrow<- data.frame(nameeg = as.character(sp), Mean1000ab = mean1000ab,   
                      Mean500ab = mean500ab,   
                      Mean350ab = mean350ab, Mean1000r = mean1000r, Mean500r = mean500r, Mean350r = mean350r,
                      NumCorr1000 = disttab1000, NumCorr500 = disttab500, NumCorr350 = disttab350, 
                      MeanRawab = meanrawab, MeanRawr = meanrawr) 
  
  SpeciesMeanbyDistance <- rbind(SpeciesMeanbyDistance, newrow)              # Apply rbind function
  
                                        } 




SynchTab <- expand.grid(StartRho0=c(0.2,0.4,0.6,0.8), 
                        StartRhoInf=c(0,0.2,0.4,0.6), 
                        StartLambda=log(c(10,20,40,80,160,320, 1000)), 
                        nameeg=Species, 
                        SynchVar=c("log.abundance", "log.r"), 
                        MaxLik=NA,
                        rho.0=NA, rho.inf=NA, Lambda=NA, MeanRhos=NA, N.areas=NA,
                        stringsAsFactors=FALSE)

SynchTab <- SynchTab[SynchTab$StartRho0>=SynchTab$StartRhoInf,] # starting values for rho0 always greater than rhoinf

for(i in 1:nrow(SynchTab))
{
  start <- SynchTab[i,c("StartRho0", "StartRhoInf", "StartLambda")]
  
  sp <- SynchTab[i,"nameeg"]
  svar <- SynchTab[i,"SynchVar"]
  synchdatawide <- SyncLists[[svar]][[sp]]
  areas <- substr(colnames(synchdatawide), nchar(svar)+2, nchar(colnames(synchdatawide))) # need to get the names of areas with data, not all areas have all birds
  disttab2 <- disttab[areas, areas] #distance matrix must have same number of row and columns as number of areas
  gausssynch <- optim(start, GaussSyncF, distmat=disttab2, x=synchdatawide)
  gausssynchFix <- optimize(GaussSyncFFix, c(-1,1), distmat=disttab2, x=synchdatawide)
  SynchTab[i,"MaxLik"] <- gausssynch$value
  SynchTab[i,"rho.0"] <- exp(gausssynch$par[1])/(1+exp(gausssynch$par[1]))
  SynchTab[i,"rho.inf"] <- SynchTab[i,"rho.0"]*exp(gausssynch$par[2])/(1+exp(gausssynch$par[2]))
  SynchTab[i,"Lambda"] <- exp(gausssynch$par[3])
  SynchTab[i,"MeanRhos"] <- gausssynchFix$minimum
  SynchTab[i,"N.areas"] <- length(areas)
  print(paste(i, "of", nrow(SynchTab)))
  flush.console()
}
save(SynchTab, file="SynchTab_Norway.rda")
load("SynchTab_Norway.rda")


synchtabb <- with(SynchTab, tapply(MaxLik, list(nameeg, SynchVar), min))
SynchTabB <- SynchTab[SynchTab$MaxLik%in%synchtabb,]
SynchTabB['Dataset'] = 'Norway'
save(SynchTabB, file="SynchTab_Norway.rda")


## Load the life history trait data ####
## Combining generation length column with species name:
## Migration classification available from: Eyres, A., K. Bohning-Gaese, and S. A. Fritz. 2017. Quantification of climatic niches in birds: adding the temporal dimension. Journal of Avian Biology 48:1517-1531.
## Generation time data available from: Bird, J. P., R. Martin, H. R. Akçakaya, J. Gilroy, I. J. Burfield, S. T. Garnett, A. Symes, J. Taylor, Ç. H. Şekercioğlu, and S. H. M. Butchart. 2020. Generation lengths of the world`s birds and their implications for extinction risk. Conservation Biology 34:1252-1261.
Migrant <- read.csv("C:\\Users\\ellencm\\NTNU\\Ellen C. Martin PhD - General\\PAPER II\\Trait Data\\LifeHistory_ForPublication.csv")
head(Migrant)

MigData <- Migrant %>%
  select(c(commonname, nameeg))

## Norway_Mig_Classification is column of manually entered migration classification per species
## Norway_Mig_Classifications come from MoveBank.org.
NorwayMigClassification <- Migrant %>%
  select(c(nameeg, Norway_Mig_Classification))

### Match species with generation time 
GenerationTime_Avian_ConsBio <- read.csv("C:\\Users\\ellencm\\NTNU\\Ellen C. Martin PhD - General\\PAPER II\\Trait Data\\GenerationTime_AvianDatabase_Bird_et_al_2020.csv")
Gen.Length <-  GenerationTime_Avian_ConsBio %>%
  select(c(nameeg, GenLength))

MigData <- merge(MigData, Gen.Length, by = "nameeg")
MigData2 <- merge(MigData, NorwayMigClassification, by = "nameeg")

## Join the migratory status of each species as new column to SynchTabB object ##
SynchTabMigMerge <- merge(SynchTabB, MigData2, by="nameeg")
## rename Norway specific classification column:
names(SynchTabMigMerge)[names(SynchTabMigMerge) == "Norway_Mig_Classification"] <- "CountrySpecificCat"
## Join the mean rho by distance as a new column to SynchTabB object
SynchTabMigMerge2<- merge(SynchTabMigMerge, SpeciesMeanbyDistance, by = "nameeg")
## Remove duplicated species 
SynchTabMigMerge2 <- SynchTabMigMerge2 [!duplicated(SynchTabMigMerge2[c(1,5,6)]),]

save(SynchTabMigMerge2, file="NORWAY_COUNTRYSPECIFIC_SYNCH.rda")
